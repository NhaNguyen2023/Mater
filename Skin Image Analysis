library(keras)
library(EBImage) #not able to install
library(ijtiff) #video, animation
library(magick) #install.packages()
library(dplyr)
library(stringr)
library(pbapply)
install_keras()

setwd("C:/Users/nhanguyen/Downloads/R/Skin/Data")
#Get the list of all images
allFiles <- list.files(path = "C:/Users/nhanguyen/Downloads/R/Skin/Data/resized training images", pattern = ".jpg", full.names = T)
allFiles1 <- list.files(path = "C:/Users/nhanguyen/Downloads/R/Skin/Data/resized training images", full.names = T)

#Get the dataframe with info
allInfo <- image_info(image_read(allFiles)) # takes a lot of time and space to read
allInfo1 <- image_info(image_read(allFiles1))

#Attach the file names
allInfo$fileName = list.files(path = "C:/Users/nhanguyen/Downloads/R/Skin/Data/resized training images", pattern = ".jpg")

#Save
write.csv(allInfo, "allImageInfo.csv")

#Read the truth
allResult <- read.csv("ISIC_2019_Training_GroundTruth.csv")
varSize <- function(data, column_name) {
  size <- sum(data[column_name])
  return(size)
}
mel <- varSize(allResult, "MEL")
mel
allResult$outcome <- ifelse(allResult$MEL==1, "MEL", ifelse(allResult$NV==1, "NV", ifelse(allResult$BCC==1, "BCC", ifelse(allResult$AK==1, "AK", ifelse(allResult$BKL==1, "BKL", ifelse(allResult$DF==1, "DF", ifelse(allResult$VASC==1, "VASC", ifelse(allResult$SCC==1, "SCC", NA))))))))

#sample <- sample(c(TRUE,FALSE), nrow(allInfo), replace=TRUE, prob=c(0.7,0.3))
#train <- allInfo[sample, ]
#validation <- allInfo[!sample, ]
#set.seed(13)
#allFilesIndex <- data.frame(createDataPartition(allFiles, p=.7, list=FALSE, times=10))
#head(allFilesIndex)

skin_img <- allInfo %>% full_join(allResult, by = join_by(name == image),keep=T)

train_x, test_x, train_y, test_y <- train_test_split(allInfo, Y, test_size=0.3, random_state=230)
#inspect the shape of training and testing
print(train_x.shape)
print(train_y.shape)
print(test_x.shape)
print(test_y.shape)

library(DMwR)
mel <- SMOTE(MEL ~ ., allInfo, perc.over = 

# Set image size
width <- 50
height <- 50
extract_feature <- function(dir_path, width, height, labelsExist = T) {
img_size <- width * height
## List images in path
images_names <- list.files(dir_path)
if(labelsExist){
## Select only cats or dogs images
catdog <- str_extract(images_names, "^(cat|dog)")
# Set cat == 0 and dog == 1
key <- c("cat" = 0, "dog" = 1)
y <- key[catdog]
}
print(paste("Start processing", length(images_names), "images"))
## This function will resize an image, turn it into greyscale
feature_list <- pblapply(images_names, function(imgname) {
## Read image
img <- readImage(file.path(dir_path, imgname))
## Resize image
img_resized <- resize(img, w = width, h = height)
## Set to grayscale (normalized to max)
grayimg <- channel(img_resized, "gray")
## Get the image as a matrix
img_matrix <- grayimg@.Data
## Coerce to a vector (row-wise)
img_vector <- as.vector(t(img_matrix))
return(img_vector)
})
## bind the list of vector into matrix
feature_matrix <- do.call(rbind, feature_list)
feature_matrix <- as.data.frame(feature_matrix)
## Set names
names(feature_matrix) <- paste0("pixel", c(1:img_size))
if(labelsExist){
return(list(X = feature_matrix, y = y))
}else{
return(feature_matrix)
}
}

# Takes approx. 15min
trainData <- extract_feature("train/", width, height)
# Takes slightly less
testData <- extract_feature("test1/", width, height, labelsExist = F)

# Check processing on second cat
par(mar = rep(0, 4))
testCat <- t(matrix(as.numeric(trainData$X[2,]),
nrow = width, ncol = height, T))
image(t(apply(testCat, 2, rev)), col = gray.colors(12),
axes = F)
# Save
save(trainData, testData, file = "catdogData.RData")

# Fix structure for 2d CNN
train_array %
layer_dropout(rate = 0.25) %>%
layer_flatten() %>%
layer_dense(units = 50, activation = "relu") %>%
layer_dropout(rate = 0.25) %>%
layer_dense(units = 1, activation = "sigmoid")
summary(model)
model %>% compile(
loss = 'binary_crossentropy',
optimizer = "adam",
metrics = c('accuracy')
)
history % fit(
x = train_array, y = as.numeric(trainData$y),
epochs = 30, batch_size = 100,
validation_split = 0.2
)
plot(history)

# Compute probabilities and predictions on test set
predictions <-  predict_classes(model, test_array)
probabilities <- predict_proba(model, test_array)
# Visual inspection of 32 cases
set.seed(100)
random <- sample(1:nrow(testData), 32)
preds <- predictions[random,]
probs <- as.vector(round(probabilities[random,], 2))
par(mfrow = c(4, 8), mar = rep(0, 4))
for(i in 1:length(random)){
image(t(apply(test_array[random[i],,,], 2, rev)),
col = gray.colors(12), axes = F)
legend("topright", legend = ifelse(preds[i] == 0, "Cat", "Dog"),
text.col = ifelse(preds[i] == 0, 2, 4), bty = "n", text.font = 2)
legend("topleft", legend = probs[i], bty = "n", col = "white")
}
# Save model
save(model, file = "CNNmodel.RData")

model.fit(train_x, train_y, epochs = 5, batch_size = 3546)
preds <- model.evaludate(test_x, test_y)
print ("Loss = " + str(preds[0]))
print ("Test Accuracy = " + str(preds[1]))
